{
  "version": 3,
  "sources": ["../src/index.tsx"],
  "sourcesContent": ["import { useCallback, useRef } from \"react\";\nimport type {\n\tStateCreator,\n\tStoreApi,\n} from \"zustand\";\nimport type { UseBoundStore } from \"zustand/react\";\nimport { create } from \"zustand\";\nimport { shallow } from \"zustand/vanilla/shallow\";\n\ninterface StoreMethods<TState extends object> {\n\tuseGlobalState<Key extends keyof TState>(\n\t\tselector: Key,\n\t\tcomparator?: (a: TState[Key], b: TState[Key]) => boolean,\n\t): TState[Key];\n\tuseStore: UseBoundStore<StoreApi<TState>>;\n\tgetStates(): TState;\n\tsetStates(newStore: TState): void;\n\tupdateStates(\n\t\tpartial: Partial<TState>,\n\t\tupdater?: (partial: Partial<TState>) => void,\n\t): void;\n\tcreatePropUpdater<Prop extends keyof TState>(\n\t\tpropName: Prop,\n\t): (\n\t\tpartial: Partial<TState[Prop]>,\n\t\tupdater?: (partial: Partial<TState>) => void,\n\t) => void;\n\tsubscribe: StoreApi<TState>[\"subscribe\"];\n}\n\nexport const createStore = function createStore<TState extends object>(\n\tinitState: TState,\n\tinitialStateCreator: StateCreator<TState, [], []> = () => initState,\n): StoreMethods<TState> {\n\ttype StoreKey = keyof TState;\n\n\t// create the store\n\tconst useStore = create<TState>(initialStateCreator);\n\n\tconst { getState: getStates, setState: setStates, subscribe } = useStore;\n\n\t// global state merger. unlike redux, I am not enforcing reducer layer\n\tconst plainObjectPrototype = Object.getPrototypeOf({});\n\tfunction isPlainObject(obj: unknown): boolean {\n\t\treturn Boolean(\n\t\t\tobj &&\n\t\t\t\ttypeof obj === \"object\" &&\n\t\t\t\tObject.getPrototypeOf(obj) === plainObjectPrototype,\n\t\t);\n\t}\n\n\tfunction shallowUpdater(partial: Partial<TState>) {\n\t\tconst store = getStates();\n\t\tconst mergedPartial: Partial<TState> = {};\n\t\tconst propNames = Object.keys(partial) as Array<keyof TState>;\n\t\twhile (propNames.length) {\n\t\t\tconst propName = propNames.shift() as keyof TState;\n\t\t\tconst oldValue = store[propName];\n\t\t\tconst newValue = partial[propName];\n\t\t\tif (isPlainObject(oldValue) && isPlainObject(newValue)) {\n\t\t\t\tconst oldObj = oldValue as Record<string, unknown>;\n\t\t\t\tconst newObj = newValue as Record<string, unknown>;\n\t\t\t\tmergedPartial[propName] = {\n\t\t\t\t\t...oldObj,\n\t\t\t\t\t...newObj,\n\t\t\t\t} as TState[keyof TState];\n\t\t\t} else {\n\t\t\t\tmergedPartial[propName] = newValue;\n\t\t\t}\n\t\t}\n\t\tsetStates({\n\t\t\t...store,\n\t\t\t...mergedPartial,\n\t\t});\n\t}\n\n\t// updateStates merges properties upto two levels of the data store\n\tfunction updateStates(\n\t\tpartial: Partial<TState>,\n\t\tupdater: (partial: Partial<TState>) => void = shallowUpdater,\n\t) {\n\t\treturn updater(partial);\n\t}\n\n\t// curry function to partially update a sub property of global store.\n\t// e.g const updateCart = createPropUpdater('cart');\n\t// updateCart({ items: [], quantity: 0 });\n\t// this is equivalent to\n\t// updateStates({ cart: { items: [], quantity: 0 } })\n\tfunction createPropUpdater<Prop extends StoreKey>(propName: Prop) {\n\t\treturn function propUpdater(\n\t\t\tpartial: Partial<TState[Prop]>,\n\t\t\tupdater: (partial: Partial<TState>) => void = shallowUpdater,\n\t\t) {\n\t\t\treturn updater({ [propName]: partial } as Partial<TState>);\n\t\t};\n\t}\n\n\tfunction useGlobalState<Key extends StoreKey>(\n\t\tpropName: Key,\n\t\tcomparator?: (a: TState[Key], b: TState[Key]) => boolean,\n\t): TState[Key] {\n\t\tconst equalityFn = comparator ?? shallow;\n\t\tconst prevRef = useRef<TState[Key] | undefined>(undefined);\n\t\tconst selectorFunction = useCallback(\n\t\t\t(store: TState) => {\n\t\t\t\tconst next = store[propName];\n\t\t\t\t// prevRef.current === undefined is there to make typescript happy\n\t\t\t\tif (prevRef.current === undefined || !equalityFn(prevRef.current, next)) {\n\t\t\t\t\tprevRef.current = next;\n\t\t\t\t}\n\t\t\t\treturn prevRef.current;\n\t\t\t},\n\t\t\t[propName, equalityFn],\n\t\t);\n\t\treturn useStore(selectorFunction);\n\t}\n\n\treturn {\n\t\tuseGlobalState,\n\t\tgetStates,\n\t\tsetStates,\n\t\tupdateStates,\n\t\tcreatePropUpdater,\n\t\t// zustand aliases\n\t\tuseStore,\n\t\tsubscribe,\n\t};\n};\n\nconst defaultStore = createStore({});\n\nexport const {\n\tuseGlobalState,\n\tgetStates,\n\tsetStates,\n\tupdateStates,\n\tcreatePropUpdater,\n\tuseStore,\n\tsubscribe,\n} = defaultStore;\n\n// -------------- app code testing ------------------\n/*\ntype MyStoreType = {\n\tgreeting: string;\n\tcart: {\n\t\ttotalQty: number;\n\t\titems: {\n\t\t\tqty: number;\n\t\t\tsku: string;\n\t\t}[];\n\t};\n\ttest: {\n\t\ttest2: string;\n\t};\n}\nconst { updateStates: updater } = createStore<MyStoreType>({\n\tgreeting: 'hi',\n\tcart: { totalQty: 0, items: [] },\n\ttest: { test2: 'hi' },\n});\nupdater({ greeting: 'hi' }); // no error\nupdater({ cart: { greeting: 'hi' } }); // error\nupdater({ cart: { cart: {} } }); // error\nupdater({ cart: { test: {} } }); // error\nupdater({ cart: { test2: 'h1' } }); // error\nupdater({ cart: { totalQty: 0, items: [] } }); // no error\n*/\n"],
  "mappings": "AAAA,OAAS,eAAAA,EAAa,UAAAC,MAAc,QAMpC,OAAS,UAAAC,MAAc,UACvB,OAAS,WAAAC,MAAe,0BAuBjB,IAAMC,EAAc,SAC1BC,EACAC,EAAoD,IAAMD,EACnC,CAIvB,IAAME,EAAWL,EAAeI,CAAmB,EAE7C,CAAE,SAAUE,EAAW,SAAUC,EAAW,UAAAC,CAAU,EAAIH,EAG1DI,EAAuB,OAAO,eAAe,CAAC,CAAC,EACrD,SAASC,EAAcC,EAAuB,CAC7C,MAAO,GACNA,GACC,OAAOA,GAAQ,UACf,OAAO,eAAeA,CAAG,IAAMF,EAElC,CAEA,SAASG,EAAeC,EAA0B,CACjD,IAAMC,EAAQR,EAAU,EAClBS,EAAiC,CAAC,EAClCC,EAAY,OAAO,KAAKH,CAAO,EACrC,KAAOG,EAAU,QAAQ,CACxB,IAAMC,EAAWD,EAAU,MAAM,EAC3BE,EAAWJ,EAAMG,CAAQ,EACzBE,EAAWN,EAAQI,CAAQ,EACjC,GAAIP,EAAcQ,CAAQ,GAAKR,EAAcS,CAAQ,EAAG,CACvD,IAAMC,EAASF,EACTG,EAASF,EACfJ,EAAcE,CAAQ,EAAI,CACzB,GAAGG,EACH,GAAGC,CACJ,CACD,MACCN,EAAcE,CAAQ,EAAIE,CAE5B,CACAZ,EAAU,CACT,GAAGO,EACH,GAAGC,CACJ,CAAC,CACF,CAGA,SAASO,EACRT,EACAU,EAA8CX,EAC7C,CACD,OAAOW,EAAQV,CAAO,CACvB,CAOA,SAASW,EAAyCP,EAAgB,CACjE,OAAO,SACNJ,EACAU,EAA8CX,EAC7C,CACD,OAAOW,EAAQ,CAAE,CAACN,CAAQ,EAAGJ,CAAQ,CAAoB,CAC1D,CACD,CAEA,SAASY,EACRR,EACAS,EACc,CACd,IAAMC,EAAaD,GAAczB,EAC3B2B,EAAU7B,EAAgC,MAAS,EACnD8B,EAAmB/B,EACvBgB,GAAkB,CAClB,IAAMgB,EAAOhB,EAAMG,CAAQ,EAE3B,OAAIW,EAAQ,UAAY,QAAa,CAACD,EAAWC,EAAQ,QAASE,CAAI,KACrEF,EAAQ,QAAUE,GAEZF,EAAQ,OAChB,EACA,CAACX,EAAUU,CAAU,CACtB,EACA,OAAOtB,EAASwB,CAAgB,CACjC,CAEA,MAAO,CACN,eAAAJ,EACA,UAAAnB,EACA,UAAAC,EACA,aAAAe,EACA,kBAAAE,EAEA,SAAAnB,EACA,UAAAG,CACD,CACD,EAEMuB,EAAe7B,EAAY,CAAC,CAAC,EAEtB,CACZ,eAAAuB,EACA,UAAAnB,EACA,UAAAC,EACA,aAAAe,EACA,kBAAAE,EACA,SAAAnB,EACA,UAAAG,CACD,EAAIuB",
  "names": ["useCallback", "useRef", "create", "shallow", "createStore", "initState", "initialStateCreator", "useStore", "getStates", "setStates", "subscribe", "plainObjectPrototype", "isPlainObject", "obj", "shallowUpdater", "partial", "store", "mergedPartial", "propNames", "propName", "oldValue", "newValue", "oldObj", "newObj", "updateStates", "updater", "createPropUpdater", "useGlobalState", "comparator", "equalityFn", "prevRef", "selectorFunction", "next", "defaultStore"]
}
